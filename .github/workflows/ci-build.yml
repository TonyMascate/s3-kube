name: CI/CD - Test, Build, Deploy (Minikube + Chat)

permissions:
  contents: read
  packages: write

on:
  push:
    branches: ["main"]
    tags: ["v*"]
  pull_request:
    branches: ["main"]

jobs:
  test:
    name: Run tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Start services (MinIO via docker-compose)
        uses: docker/setup-compose-action@v1

      - run: docker compose -f docker-compose.yml up -d

      - name: Install GTK dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libglib2.0-dev pkg-config

      - name: Run Go tests
        run: go test ./... -v
        env:
          MINIO_ENDPOINT: "localhost:9000"
          MINIO_ACCESS_KEY: "minioadmin"
          MINIO_SECRET_KEY: "miniopassword"

      - if: always()
        run: docker compose -f docker-compose.yml down --volumes --remove-orphans

  build-and-push:
    name: Build & Push Docker image
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - id: vars
        name: Determine image tag
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
          else
            TAG="latest"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Prepare lowercase owner
        id: lc
        run: echo "lc_owner=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ghcr.io/${{ steps.lc.outputs.lc_owner }}/mys3:${{ steps.vars.outputs.tag }}
            ghcr.io/${{ steps.lc.outputs.lc_owner }}/mys3:${{ github.sha }}

  deploy-to-minikube:
    name: Deploy to local Minikube
    runs-on: [self-hosted, minikube]
    needs: [build-and-push]
    steps:
      - uses: actions/checkout@v4

      - name: Ensure Minikube is running
        shell: bash
        run: |
          echo "ðŸ” VÃ©rification de Minikube..."
          minikube status || minikube start --driver=docker

      - name: Prepare lowercase owner
        id: lc
        shell: bash
        run: echo "lc_owner=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Load image into Minikube
        shell: bash
        run: |
          echo "ðŸ“¦ Chargement de l'image dans Minikube..."
          minikube image pull ghcr.io/${{ steps.lc.outputs.lc_owner }}/mys3:${{ github.sha }}

      - name: Apply Kubernetes manifests and update image
        shell: bash
        run: |
          echo "ðŸš€ DÃ©ploiement de k8s/k8s-all.yaml..."
          kubectl apply -f k8s/k8s-all.yaml

          IMAGE_TAG=${{ github.sha }}
          IMAGE_NAME="ghcr.io/${{ steps.lc.outputs.lc_owner }}/mys3:${IMAGE_TAG}"

          echo "ðŸ”„ Mise Ã  jour de l'image de mys3-deployment avec ${IMAGE_NAME}..."
          kubectl set image deployment/mys3-deployment mys3=${IMAGE_NAME}

          echo "â³ Attente du dÃ©ploiement..."
          if ! kubectl rollout status deployment/mys3-deployment --timeout=120s; then
            echo "âŒ Le dÃ©ploiement a Ã©chouÃ©. Voici les Ã©vÃ©nements :"
            kubectl describe deployment mys3-deployment
            echo "ðŸ” Logs du pod :"
            kubectl logs deployment/mys3-deployment || true
            exit 1
          fi

      - name: Verify deployed services
        shell: bash
        run: |
          echo "âœ… VÃ©rification du dÃ©ploiement :"
          kubectl get pods
          kubectl get svc

  notify:
    name: Notify Google Chat
    runs-on: ubuntu-latest
    needs: [test, build-and-push, deploy-to-minikube]
    if: always()
    steps:
      - name: Determine global pipeline status
        id: result
        run: |
          if [[ "${{ needs.test.result }}" == "failure" || \
                "${{ needs.build-and-push.result }}" == "failure" || \
                "${{ needs.deploy-to-minikube.result }}" == "failure" ]]; then
            echo "status=failure" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
          fi

      - name: Prepare notification message
        id: message
        run: |
          STATUS=${{ steps.result.outputs.status }}
          REPO=${{ github.repository }}
          ACTOR=${{ github.actor }}
          COMMIT=${{ github.sha }}
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          if [ "$STATUS" = "success" ]; then
            EMOJI="âœ…"
            MESSAGE="La pipeline CI/CD s'est terminÃ©e avec succÃ¨s ðŸŽ‰"
            DETAILS="*Statut :* âœ… SuccÃ¨s%0A*Auteur :* $ACTOR%0A*Commit :* [$COMMIT]($RUN_URL)"
          else
            EMOJI="âŒ"
            MESSAGE="La pipeline CI/CD a Ã©chouÃ© ðŸš¨"
            DETAILS="*Statut :* âŒ Ã‰chec%0A*Auteur :* $ACTOR%0A*Commit :* [$COMMIT]($RUN_URL)%0A*Erreur :* Consultez les logs du job dÃ©faillant."
          fi

          echo "text=$EMOJI $MESSAGE%0A$DETAILS" >> $GITHUB_OUTPUT

      - name: Send notification to Google Chat
        uses: Co-qn/google-chat-notification@v1
        if: always()
        with:
          name: "CI/CD - ${{ github.repository }}"
          url: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
          status: ${{ steps.result.outputs.status }}
          message: ${{ steps.message.outputs.text }}
